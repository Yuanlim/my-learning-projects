// utility types | modifiers

// Partial: partially assign a type | interface

const invHas = ['pickaxe', 'sword', 'shovel'] as const;
type InvHas = (typeof invHas)[number];

type Character = {
  name: string;
  attack: number;
  hp: number;
  isDead: boolean;
  inv?: string[];
};

const updateCharacter = (character: Character, assign: Partial<Character>): Character => {
  return { ...character, ...assign };
};

const updateRefCharacter = (character: Character, assign: Partial<Character>): void => {
  Object.assign(character, assign);
};

let steve: Character = {
  name: 'Steve',
  hp: 10,
  attack: 110,
  isDead: false,
};

console.log(updateCharacter(steve, { hp: 0 })); // doesn't change original when assign.
steve = updateCharacter(steve, { isDead: true });
console.log(steve);

let Alex: Character = {
  name: 'Steve',
  hp: 10,
  attack: 110,
  isDead: false,
};
updateRefCharacter(Alex, { hp: 0 }); // Objectly/Addressly assign
updateRefCharacter(Alex, { isDead: true });
console.log(Alex);

////////////////////////////////////////////////////////////////////////////////////////////

// Readonly and Required
// Readonly: once declared the property can't be change only read.
// Required: it means a can be nullable "i.e. string?" properties now is being required to pass in.

const completedAssign = (character: Character, assign: Required<Character>) => {
  Object.assign(character, assign);
};

// implement Python range
// function*: means iteratable functions use keyword "yeid" to declared next return
function* range(rangeValue: number) {
  if (!Number.isInteger(rangeValue) || rangeValue < 0)
    throw new Error('Param Error: pass in rangeValue must be integer and non-negative');

  for (let index = 0; index < rangeValue; index++) yield index;
}

const randIndex = (max: number): number => {
  return Math.floor(Math.random() * max);
};

// unknown[] over any[]
// any: anything can be assign, any method of any type can be used
// unknown: anything can be assign, but when used type method you have to condition first
// narrow it down to a type
function pick<T extends readonly unknown[]>(arr: T): T[number] {
  return arr[randIndex(arr.length)];
}

// initialize steve inventory
let inv = [];
// for of: an object-specific iterator and loops over the values generated by that
for (const _ of range(3)) {
  inv.push(pick(invHas));
}
completedAssign(steve, { ...steve, inv: inv });
console.log(steve);
///////////////////////////////////////////////////////////////////////////////////////////

// Record: defining a value that has keys and its type
const RGB: Record<string, number> = {
  R: 255,
  G: 255,
  B: 255,
};

// Known student name Student (literal) assign its grade A,B,... (literal)
// when indexing student name it should return its grade.
// Also teacher should be able to insert different test results
// test results also has keys as course name.
const student = ['Alice', 'Josh'] as const;
type StudentName = (typeof student)[number];
type Grade = 'A' | 'B' | 'C' | 'D' | 'F';
const GRADE: readonly Grade[] = ['A', 'B', 'C', 'D', 'F'];
type CourseTestResult = Record<string, number>;
type Info = { grade: Grade; result: CourseTestResult };
type GradeBook = Record<StudentName, Info>;

function fromEntries<K extends PropertyKey, V>(
  entries: readonly (readonly [K, V])[],
): { [P in K]: V } {
  return Object.fromEntries(entries) as any;
}

const DEFAULT_INFO: Info = { grade: 'F', result: { 'C#': 0 } };

class Grading {
  #Book: GradeBook;

  constructor(seed?: Partial<GradeBook>) {
    const entries = student.map((s) => [s, { ...DEFAULT_INFO }] as const);
    this.#Book = fromEntries(entries);

    if (seed)
      for (const k of Object.keys(seed) as StudentName[]) {
        this.#Book[k] = seed[k]!;
      }
  }

  public get Book(): GradeBook {
    return this.#Book;
  }

  public gradeByKey(k: StudentName): Grade {
    return this.#Book[k].grade;
  }

  public testResultByKey(k: StudentName): CourseTestResult {
    return this.#Book[k].result;
  }

  public completeAssign(v: Required<Info>, k: StudentName): void {
    this.#Book[k] = v;
  }

  public updateAssign(v: Grade, k: StudentName): void;
  public updateAssign(v: CourseTestResult, k: StudentName): void;
  public updateAssign(v: Grade | CourseTestResult, k: StudentName): void {
    if (this.isGrade(v)) this.#Book[k].grade = v;
    if (this.isCTR(v)) this.#Book[k].result = v;
    else console.log('Not changing');
  }

  public toInfo(g: Grade, r: CourseTestResult): Info {
    return { grade: g, result: r };
  }

  // v is Grade: auto casting type after checks
  private isGrade(v: unknown): v is Grade {
    return typeof v === 'string' && (GRADE as readonly string[]).includes(v);
  }

  private isCTR(v: unknown): v is CourseTestResult {
    if (typeof v !== 'object' || v === null || Array.isArray(v)) return false;

    return Object.values(v).every((v) => typeof v === 'number' && Number.isFinite(v));
  }
}

const g = new Grading();

console.log('Default book:', g.Book);

g.updateAssign('B' as Grade, 'Alice');
console.log('Alice grade ->', g.gradeByKey('Alice')); // B

const results: CourseTestResult = { TS: 88, 'C#': 91 };
g.updateAssign(results, 'Alice');
console.log('Alice results ->', g.testResultByKey('Alice')); // {TS:88, C#:91}

g.completeAssign({ grade: 'A', result: { TS: 100, 'C#': 100 } }, 'Josh');
console.log('Josh ->', g.Book.Josh);

console.log('Final snapshot:', g.Book);

// Pick and Omit
// Pick: “pick” in existing type propreties that you only want to construct.
// Omit: "exclude" in existing type propreties that you dont want.
type IUser = {
  userId: number;
  name: string;
  phone: string;
  address: string;
  passwordFailedT: number;
};

type UserTypeUN = Pick<IUser, 'userId' | 'name'>;
const UserDave: UserTypeUN = {
  userId: 1,
  name: 'Dave',
};

type UserTypeNPA = Omit<IUser, 'userId' | 'passwordFailedT'>;
const UserLily: UserTypeNPA = {
  name: 'Lily',
  phone: '9870190280',
  address: 'wjosjdfsk',
};

console.log(UserDave);
console.log(UserLily);

/////////////////////////////////////////////////////////////////////////
// Exclude and Extract
// Exclude: delete an existing literal possibility and assign it as a new type.
// Extract: include an existing literal possibility and assign it as a new type.
type AdjustingGrade = Exclude<Grade, 'F'>; // Excluding failed grade
type HighGrade = Extract<Grade, 'A' | 'B'>; // Extracting only high grade

//////////////////////////////////////////////////////////////////////////
// Nonnullable: when the type is initiallize as can nullable or undifined. This keyword makes it unnullable and assign it as a new type.
type ComputerModel = 'Asus' | 'MSI' | null | undefined;
type ComputerModelOnly = NonNullable<ComputerModel>; // hover on "ComputerModelOnly" checks null and undefined is not an acception anymore.

////////////////////////////////////////////////////////////////////////////
// ReturnType: automatic sees the function return and accept it as its type and the return type of the function is also auto setup as the type.

function createNewInfoV2(grade: Grade, result: CourseTestResult) {
  return { grade, result }; // doesnt know the return type but properties is set.
}

type InfoV2 = ReturnType<typeof createNewInfoV2>; // now the type is known as InfoV2, change the return of createNewInfoV2, results the automatic change of InfoV2 type structural as well.

const daveGrade: InfoV2 = createNewInfoV2('A', { 'C#': 77 });
console.log(daveGrade);

//////////////////////////////////////////////////////////////////////////
// Parameters: instead of defining the types of what the function returns, this keyword set argument as a new type.
type AugType = Parameters<typeof createNewInfoV2>;
const firstInput: AugType = ['A', { TS: 88 }];
const lilyGrade: InfoV2 = createNewInfoV2(...firstInput);
console.log(lilyGrade);

//////////////////////////////////////////////////////////////////////////
// Promise: come back later i promise you, i will return the type.
// Await: When searching thread is not hold in time waited for it to finish.
// Async: Used when a function use await.

interface someUserData {
  id: number;
  name: string;
  username: string;
  email: string;
}

async function fetchUsers(): Promise<someUserData[]> {
  try {
    const res = await fetch('https://jsonplaceholder.typicode.com/users');

    if (!res.ok) {
      throw new Error(`HTTP ${res.status} ${res.statusText}`);
    }

    const data: unknown = await res.json();
    return data as someUserData[];
  } catch (error) {
    if (error instanceof Error) {
      console.log(error.message);
    } else {
      console.log('Unknown error' + error);
    }

    return [];
  }
}

type fetchUsersType = Awaited<ReturnType<typeof fetchUsers>>;
const jsonUsers: fetchUsersType = await fetchUsers();
console.log(jsonUsers);
